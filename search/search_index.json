{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Technischer Setup","text":"Technologie oder Tool Version Apache Maven 3.9.8 IntelliJ IDEA Community Edition 2024.2.1 Java Version 21.0.4, Amazon Corretto, Amazon.com Inc. Language Level 21 - Record patterns, pattern matching for switch"},{"location":"mkdocs/","title":"Lokale Nutzung der Lab-Beschreibung","text":"<p>F\u00fcr die Beschreibung wird MkDocs verwendet. Die wichtigsten Command f\u00fcr die lokale Nutzung sind:</p> <ul> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"mkdocs/#installation-von-mkdocs","title":"Installation von MkDocs","text":"<p>Siehe MkDocs Installation Guide.</p>"},{"location":"mkdocs/#installation-unter-ubuntu","title":"Installation unter Ubuntu","text":""},{"location":"mkdocs/#installation-von-python","title":"Installation von Python","text":"<pre><code>sudo apt-get install python3\n</code></pre>"},{"location":"mkdocs/#installation-von-pip","title":"Installation von Pip","text":"<pre><code>sudo apt-get install pip\n</code></pre> <p>Installation \u00fcberpr\u00fcfen:</p> <pre><code>pip -V\n</code></pre>"},{"location":"mkdocs/#installation-unter-windows","title":"Installation unter Windows","text":""},{"location":"mkdocs/#installation-von-python-und-pip","title":"Installation von Python und Pip","text":"<p>Windows-Installer ist hier verf\u00fcgbar.</p> <p>Installation \u00fcberpr\u00fcfen:</p> <pre><code>pip -V\n</code></pre>"},{"location":"mkdocs/#installation-von-mkdocs_1","title":"Installation von MkDocs","text":"<pre><code>pip install mkdocs\n</code></pre> <pre><code>pip install mkdocs-material\n</code></pre> <pre><code>pip install mkdocs-material-extensions\n</code></pre>"},{"location":"mkdocs/#lab-beschreibung-lokal-veroffentlichen","title":"Lab-Beschreibung lokal ver\u00f6ffentlichen","text":"<pre><code>mkdocs build\n</code></pre> <pre><code>mkddocs serve\n</code></pre> <p>Open in browser (http://127.0.0.1:8000/hexacleanws/)</p>"},{"location":"docs/help/git/","title":"Git","text":"<p>This section describes some useful git basics how you can \"copy\" it to your own remote repo.</p> <ul> <li>Fork The Repository</li> <li>Custom Repository<ul> <li>Clone</li> <li>Change the Remote</li> </ul> </li> </ul>"},{"location":"docs/help/git/#fork-the-repository","title":"Fork The Repository","text":"<p>If you want to keep track of the original repository, but add your own branches simply  fork it.</p> <ol> <li>Navigate to the repository: https://github.com/MatthiasEschhold/hexacleanws</li> <li>In the top-right corner of the page, click Fork.    </li> <li>Do not select Copy the DEFAULT branch only.    </li> <li>Click Create fork. \ud83c\udf89</li> </ol>"},{"location":"docs/help/git/#custom-repository","title":"Custom Repository","text":"<p>If forking the repository is not an option, you need to change the remote origin to yours after cloning it:</p>"},{"location":"docs/help/git/#clone","title":"Clone","text":"<p>To clone the repository simply run:</p> <pre><code>$ git clone https://github.com/MatthiasEschhold/hexacleanws.git\n</code></pre>"},{"location":"docs/help/git/#change-the-remote","title":"Change the Remote","text":"<p>To change the remote origin to your custom one, rename the old one and set the new one:</p> <pre><code># Rename the current origin\n$ git remote rename origin MatthiasEschhold-origin\n\n# Set the new remote origin\n$ git remote set-url origin &lt;https://git-repo/new-repository.git&gt;\n</code></pre>"},{"location":"docs/lab1/lab1/","title":"Aufgabe 1 Dom\u00e4nenmodell Vehicle","text":""},{"location":"docs/lab1/lab1/#lernziele","title":"Lernziele","text":"<ul> <li>Stereotyp Value Object verstehen und anwenden k\u00f6nnen</li> <li>Stereotyp Root Entity verstehen und anwenden k\u00f6nnen</li> <li>Fundament des Entities Ring / Domain Hexagon verstehen</li> </ul>"},{"location":"docs/lab1/lab1/#aufgabe-11-grundstruktur-root-entity-vehicle","title":"Aufgabe 1.1 Grundstruktur Root Entity Vehicle","text":"<ul> <li>Implementiere die in der Tabelle aufgef\u00fchrten Dom\u00e4nenobjekte des Dom\u00e4nenmodells der Root Entity Vehicle (siehe Abb. 1)  </li> <li>Erstelle das Package vehicle.domain.model und lege die Dom\u00e4nenobjekte in diesem Package ab</li> <li>Implementiere die im folgenden aufgef\u00fchrten Validierungsregeln in den betroffenen Dom\u00e4nenobjekten</li> <li>Erstelle einen Unit-Test f\u00fcr jedes Dom\u00e4nenobjekt zum Testen der Objekterzeugung und Validierung</li> </ul> <p>  Abb 1: Vehicle Domain Model</p> Dom\u00e4nenobjekt Validierungsregel und Verhalten Vehicle Die Eigenschaften Vin, LicensePlate und Mileage m\u00fcssen bei einer initialen Fahrzeuganlage immer vorhanden sein. Das Datum der Kilometerstandsmeldung wird innerhalb der Dom\u00e4ne erzeugt. Vin Ein valider Wert muss dem vorgesehenen Pattern folgen. LicensePlate Ein valider Wert muss dem vorgesehenen Pattern folgen. Mileage Der Kilometerstand muss gr\u00f6\u00dfer 0 sein. MileageRecord Keine Nullwerte. RecordDate Kein Nullwert. VehicleMasterData Die Eigenschaften CountryOfManufacture und Equipment m\u00fcssen bei einer initialen Fahrzeuganlage immer vorhanden sein. Equipment Keine Nullwerte. EquipmentCode Ein valider Wert muss dem vorgesehenen Pattern folgen. EquipmentLabel Ein valider Wert muss dem vorgesehenen Pattern folgen."},{"location":"docs/lab1/lab1/#regex-pattern-fur-das-value-object-vin","title":"Regex Pattern f\u00fcr das Value Object Vin","text":"<p>Beispiele:</p> <ul> <li>WP0ZZZ99ZTS392155</li> <li>WBAOLZ99ZTS349156</li> </ul> <pre><code>\"(?=.*\\\\d|=.*[A-Z])(?=.*[A-Z])[A-Z0-9]{17}\"\n</code></pre>"},{"location":"docs/lab1/lab1/#regex-pattern-fur-das-value-object-licenseplate","title":"Regex Pattern f\u00fcr das Value Object LicensePlate","text":"<p>Beispiele:</p> <ul> <li>B-AB 123 </li> <li>ES-CD 456</li> </ul> <pre><code>\"^[A-Z]{1,3}[a-z]{0,1}[-]{0,1}[A-Z]{0,2}\\\\s[0-9]{1,5}(\\\\s){0,1}[A-Z]{0,1}[a-z]{0,2}$\"\n</code></pre>"},{"location":"docs/lab1/lab1/#regex-pattern-fur-das-value-object-countryofmanufacture","title":"Regex Pattern f\u00fcr das Value Object CountryOfManufacture","text":"<p>Beispiele:</p> <ul> <li>US </li> <li>DE</li> </ul> <pre><code>\"^[A-Z]{2}$\"\n</code></pre>"},{"location":"docs/lab1/lab1/#regex-pattern-fur-das-value-object-equipmentlabel","title":"Regex Pattern f\u00fcr das Value Object EquipmentLabel","text":"<p>Nur Buchstaben und Leerzeichen sind erlaubt.</p> <pre><code>\"^[A-Za-z\\\\s]+$\"\n</code></pre>"},{"location":"docs/lab1/lab1/#regex-pattern-fur-das-value-object-equipmentcode","title":"Regex Pattern f\u00fcr das Value Object EquipmentCode","text":"<p>Beispiele:</p> <ul> <li>AB1234</li> <li>UC7934</li> </ul> <pre><code>\"^[A-Z]{2}[0-9]{4}$\"\n</code></pre>"},{"location":"docs/lab1/lab1/#aufgabe-12-rich-domain-model-verhalten-am-domanenobjekt","title":"Aufgabe 1.2 Rich Domain Model - Verhalten am Dom\u00e4nenobjekt","text":"<p>Implementiere die Aktualisierung des Kilometerstandes mit Plausibilit\u00e4tspr\u00fcfung.  Dabei gilt das gleiche, wie bei der Fahrzeuganlage. Das Datum der Kilometerstandsmeldung wird innerhalb der Dom\u00e4ne erzeugt. Wir m\u00f6chten aus fachlicher Sicht verhindern, dass Kilometerstandmeldungen r\u00fcckwirkend durchgef\u00fchrt werden k\u00f6nnen.</p>"},{"location":"docs/lab1/lab1/#plausibilitatsprufung-fur-den-kilometerstand","title":"Plausibilit\u00e4tspr\u00fcfung f\u00fcr den Kilometerstand","text":"<pre><code>neuer Kilometerstand &gt; zuletzt gemeldeter Kilometerstand\n</code></pre>"},{"location":"docs/lab1/lab1/#hilfestellung-fur-die-unit-tests","title":"Hilfestellung f\u00fcr die Unit-Tests","text":""},{"location":"docs/lab1/lab1/#beispiel-test-fur-das-value-object-vin","title":"Beispiel-Test f\u00fcr das Value Object Vin","text":"<pre><code>class VinTest {\n\n    private final static List&lt;String&gt; VALID_VIN_LIST = Arrays.asList(\n            \"KMHDU4ADXAU832403\", //2010 Hyundai Elantra\n            \"1GCHC33N7RJ376544\", //1994 Chevrolet C/K 3500\n            \"2S3TD52V3Y6103456\", //2000 Suzuki Esteem\n            \"1G1ZT51816F264066\", //2006 Chevrolet Malibu\n            \"1GBJK34G32E254979\" //2002 Chevrolet Silverado 3500\n    );\n\n    private final static List&lt;String&gt; INVALID_VIN_LIST = Arrays.asList(\n            null,\n            \"\",\n            \" \",\n            \"K 234 Lm\",\n            \"123445667\",\n            \"WERTTZUUKHGH\"\n    );\n\n    @Test\n    void shouldCreateValidVinValueObject() {\n        VALID_VIN_LIST.forEach(vin -&gt; assertDoesNotThrow(() -&gt; new Vin(vin)));\n    }\n\n    @Test\n    void shouldThrowIllegalArgumentExceptionDueToInvalidVinValue() {\n        INVALID_VIN_LIST.forEach(vin -&gt; assertThrows(IllegalArgumentException.class, () -&gt; new Vin(vin)));\n    }\n}\n</code></pre>"},{"location":"docs/lab1/lab1/#beispiel-test-fur-das-value-object-licenseplate","title":"Beispiel-Test f\u00fcr das Value Object LicensePlate","text":"<pre><code>public class LicensePlateTest {\n\n    private final static List&lt;String&gt; AUSTRIA_LICENSE_PLATE_LIST = Arrays.asList(\n            \"A 1 B\",\n            \"X 12 Y\",\n            \"Zz 123 Ab\",\n            \"K 234 Lm\",\n            \"Mn 345 Op\",\n            \"Pq 456 Rst\",\n            \"Uv 567 Wxy\",\n            \"Zz 678 Xyz\",\n            \"Aa 789 Bcd\",\n            \"Ef 890 Ghi\"\n    );\n    private final static List&lt;String&gt; GERMAN_LICENSE_PLATE_LIST = Arrays.asList(\n            \"EES-EL 0815\",\n            \"EES-EL 815\",\n            \"EES-EL 15\",\n            \"EES-EL 5\",\n            \"EES-L 0815\",\n            \"EES-L 085\",\n            \"EES-L 08\",\n            \"EES-L 5\",\n            \"ES-EL 0815\",\n            \"ES-EL 085\",\n            \"ES-EL 08\",\n            \"ES-EL 0\",\n            \"ES-L 0815\",\n            \"ES-L 085\",\n            \"ES-L 08\",\n            \"ES-L 5\",\n            \"E-EL 0815\",\n            \"E-EL 085\",\n            \"E-EL 08\",\n            \"E-EL 0\",\n            \"E-L 0815\",\n            \"E-L 085\",\n            \"E-L 08\",\n            \"E-L 5\");\n\n    @Test\n    public void shouldCreateValidEuLicensePlateValueObjects() {\n        List&lt;String&gt; inputList = new ArrayList&lt;&gt;();\n        inputList.addAll(GERMAN_LICENSE_PLATE_LIST);\n        inputList.addAll(AUSTRIA_LICENSE_PLATE_LIST);\n        List&lt;LicensePlate&gt; licensePlateList = createLicensePlateValueObjects(inputList);\n        assertThat(licensePlateList, everyItem(hasValueInList(inputList)));\n    }\n\n    @Test\n    public void shouldThrowExceptionForInvalidEuLicensePlateValueObjects() {\n        List&lt;String&gt; inputList = new ArrayList&lt;&gt;();\n        inputList.addAll(Arrays.asList(\"123456\", \"A 1 B C\", \"EES-EL 0815 123\"));\n        for (String input : inputList) {\n            assertThrows(IllegalArgumentException.class, () -&gt; new LicensePlate(input));\n        }\n    }\n\n    /**\n     * Hamcrest could not handle records, due to this hasProperty(\"value\", inList(stringList()) does not work\n     *\n     * @param stringList\n     * @return\n     */\n    private Matcher&lt;LicensePlate&gt; hasValueInList(List&lt;String&gt; stringList) {\n        return new TypeSafeMatcher&lt;&gt;() {\n            @Override\n            protected boolean matchesSafely(LicensePlate licensePlate) {\n                return stringList.contains(licensePlate.value());\n            }\n\n            @Override\n            public void describeTo(Description description) {\n                description.appendText(\"value should be in the list\");\n            }\n        };\n    }\n\n    private List&lt;LicensePlate&gt; createLicensePlateValueObjects(List&lt;String&gt; stringList) {\n        return stringList.stream()\n                .map(LicensePlate::new)\n                .toList();\n    }\n}\n</code></pre>"},{"location":"docs/lab2/lab2/","title":"Aufgabe 2 Anwendungsf\u00e4lle der Root Entity Vehicle","text":""},{"location":"docs/lab2/lab2/#lernziele","title":"Lernziele","text":"<ul> <li>Stereotyp Use Case Input Port verstehen und anwenden k\u00f6nnen</li> <li>Stereotyp Use Case Output Port verstehen und anwenden k\u00f6nnen</li> <li>Stereotyp Interactor verstehen und anwenden k\u00f6nnen</li> <li>Aufgaben des Use Cases Ring / Application Hexagon verstehen</li> </ul>"},{"location":"docs/lab2/lab2/#auflosen-von-abhangigkeiten","title":"Aufl\u00f6sen von Abh\u00e4ngigkeiten","text":"<p>Abh\u00e4ngigkeiten zwischen Klassen, wie beispielsweise Interactor und Use Case Output Port, werden durch Dependency Injection  (konkret mittels Constructor Injection) aufgel\u00f6st. In der Demo-Anwendung ist hierf\u00fcr ein parametrisierter Konstruktor erforderlich.  Es wird weiterhin angenommen, dass ein Framework oder eine Bibliothek einen Injector bereitstellt  und die Konstruktor-basierte Injizierung der Abh\u00e4ngigkeiten \u00fcbernimmt. Die Funktionsf\u00e4higkeit ist in der Demo-Anwendung nicht notwendig.</p> <p>Alternativ zur Dependency Injection kann auch das Factory Pattern verwendet werden.</p> <p>Diese Regelung gilt f\u00fcr alle \u00dcbungsaufgaben ab Aufgabe 2.</p>"},{"location":"docs/lab2/lab2/#aufgabe-20-basisstruktur-des-use-cases-ring-anlegen","title":"Aufgabe 2.0 Basisstruktur des Use Cases Ring anlegen","text":"<ul> <li>Erstelle das Package vehicle.usecase.in</li> <li>Erstelle das Package vehicle.usecase.out</li> <li>Erstelle das Package vehicle.usecase.interactor</li> </ul>"},{"location":"docs/lab2/lab2/#aufgabe-21-anwendungsfall-fahrzeug-anlegen","title":"Aufgabe 2.1 Anwendungsfall Fahrzeug anlegen","text":"<ul> <li>Erstelle die notwendigen ein- und ausgehenden Use Cases f\u00fcr die Fahrzeuganlage</li> <li>Entscheide dich f\u00fcr einen Use-Case-Schnitt (mit Begr\u00fcndung)</li> <li>Erstelle den Use Case Interactor des Anwendungsfalls \"Fahrzeug anlegen\"</li> <li>Leg die Klassen in die entsprechenden Packages ab</li> <li>Erstelle einen Unit-Test f\u00fcr den Interactor</li> <li>Hier wir die Verwendung einer Mocking-Library, wie z.B. mockito, notwendig</li> </ul>"},{"location":"docs/lab2/lab2/#schnittstellenbeschreibung-fahrzeug-anlegen","title":"Schnittstellenbeschreibung Fahrzeug anlegen","text":"Schnittstellenelement Dom\u00e4nenobjekte Parameter Vin, LicensePlate, Mileage R\u00fcckgabe Vehicle"},{"location":"docs/lab2/lab2/#ablauf-flow-of-control-des-anwendungsfalls-happy-path","title":"Ablauf (Flow of Control) des Anwendungsfalls (Happy Path)","text":"<ul> <li>Abfrage der Fahrzeugstammdaten bei einem externen Service anhand der Vin</li> <li>Erstellung des Fahrzeugs und der intialen Kilometerstandsmeldung</li> <li>Speichern des Fahrzeugs</li> </ul> <p>Scope beachten! Use Cases Ring!</p>"},{"location":"docs/lab2/lab2/#aufgabe-22-anwendungsfall-kilometerstand-aktualisieren","title":"Aufgabe 2.2 Anwendungsfall Kilometerstand aktualisieren","text":"<ul> <li>Erstelle die notwendigen ein- und ausgehenden Use Case f\u00fcr die Kilometerstandaktualisierung</li> <li>Entscheide dich f\u00fcr einen Use-Case-Schnitt (mit Begr\u00fcndung)</li> <li>Erstelle den Use Case Interactor des Anwendungsfalls</li> <li>Leg die Klassen in die entsprechenden Packages ab</li> <li>Erstelle einen Unit-Test f\u00fcr den Interactor</li> <li>Hier wir die Verwendung einer Mocking-Library, wie z.B. mockito, notwendig</li> </ul>"},{"location":"docs/lab2/lab2/#schnittstellenbeschreibung-kilometerstand-aktualisieren","title":"Schnittstellenbeschreibung Kilometerstand aktualisieren","text":"Schnittstellenelement Dom\u00e4nenobjekte Parameter Vin, Mileage R\u00fcckgabe void"},{"location":"docs/lab2/lab2/#ablauf-flow-of-control-des-anwendungsfalls-happy-path_1","title":"Ablauf (Flow of Control) des Anwendungsfalls (Happy Path)","text":"<ul> <li>Auslesen des Fahrzeugs aus der Datenbank anhand der Vin </li> <li>Plausibilit\u00e4tspr\u00fcfung der Kilometerstandsmeldung</li> <li>Aktualisierung des Kilometerstands</li> <li>Speichern des Fahrzeugs</li> </ul>"},{"location":"docs/lab2/lab2/#aufgabe-23-erweiterung-des-anwendungsfalls-fahrzeug-anlegen-um-die-diebstahlprufung","title":"Aufgabe 2.3 Erweiterung des Anwendungsfalls Fahrzeug anlegen um die Diebstahlpr\u00fcfung","text":""},{"location":"docs/lab2/lab2/#beschreibung","title":"Beschreibung","text":"<ul> <li>Bei der Fahrzeuganlage ist eine Diebstahlpr\u00fcfung durchzuf\u00fchren</li> <li>Die Diebstahlpr\u00fcfung besteht aus Risikobewertung und Abfrage des Diebstahlstatus </li> <li>Risikobewertung: Welches Risiko besteht, dass das Fahrzeug geklaut sein k\u00f6nnte</li> <li>Abfrage des Diebstahlstatus: Abfrage des Diebstahlstatus anhand der Vin bei Interpol</li> <li>Ist die Diebstahlpr\u00fcfung negativ, wird das Fahrzeug, wie unter 2.1 beschrieben, angelegt</li> </ul>"},{"location":"docs/lab2/lab2/#diebstahlprufung-und-risikobewertung","title":"Diebstahlpr\u00fcfung und Risikobewertung","text":""},{"location":"docs/lab2/lab2/#ermittlung-des-riskscore","title":"Ermittlung des RiskScore","text":"Risikofaktor Beschreibung des Risikofaktor Bewertung des Risikofaktor (Risk Score Points) Hatte das Fahrzeug einen nachvollziehbaren Grenz\u00fcbergang? - Herstellungsland != Land der Registrierung - Land der Registrierung wird anhand des Kennzeichen ermitteln +10 Ist das Fahrzeug in einem Risikoland angemeldet? - Liste von Risikol\u00e4nder wird von einem externen Service bereitgestellt - Land der Registrierung wird anhand des Kennzeichen ermitteln +20 Beide Risikofaktoren treffen zur gleichen Zeit zu? - +30"},{"location":"docs/lab2/lab2/#anwendungsfall-spezifische-regel-risk-score-50","title":"Anwendungsfall-spezifische Regel \"Risk Score &gt;=50\"","text":"<p>WENN der RiskScore &gt;= 50 ist, DANN f\u00fchre eine Diebstahlstatusabfrage bei Interpol durch.</p>"},{"location":"docs/lab2/lab2/#aufgabe","title":"Aufgabe","text":"<ul> <li>F\u00fchre die notwendigen ein- und ausgehende Use Cases ein</li> <li>Entscheide dich f\u00fcr einen Use-Case-Schnitt (mit Begr\u00fcndung)</li> <li>Erstelle das Package vehicle.domain.service und erstelle den Domain Service f\u00fcr die Ermittlung des RiskScore</li> <li>Welche neuen Dom\u00e4nenobjekte werden ben\u00f6tigt und wie k\u00f6nnen diese im Package-Baum eingeordnet werden?</li> <li>Es ist alles erlaubt: Umbenennen, verschieben, neues Packages, etc.</li> <li>Erweitere den Unit-Test f\u00fcr den Interactor des Anwendungsfalls \"Fahrzeug anlegen\"</li> <li>Schreibe einen Unit-Test f\u00fcr den Domain Service f\u00fcr die Ermittlung des RiskScore</li> </ul>"},{"location":"docs/lab2/lab2/#ablauf-flow-of-control-des-anwendungsfalls-happy-path_2","title":"Ablauf (Flow of Control) des Anwendungsfalls (Happy Path)","text":"<ul> <li>Ermittlung des Risikoscore</li> <li>Auswertung des Risikoscore und bei Bedarf Abfrage des Diebstahlstatus</li> <li>Abfrage der Fahrzeugdaten bei einem externen Service anhand der Vin</li> <li>Erstellung des Fahrzeugs und der initialen Kilometerstandsmeldung</li> <li>Speichern des Fahrzeugs</li> </ul>"},{"location":"docs/lab2/lab2/#externe-schnittstellen","title":"Externe Schnittstellen","text":""},{"location":"docs/lab2/lab2/#schnittstellenbeschreibung-externer-service-fur-risikolander","title":"Schnittstellenbeschreibung externer Service f\u00fcr Risikol\u00e4nder","text":"Schnittstellenelement Dom\u00e4nenobjekte Parameter Keine R\u00fcckgabe List(RiskCountry)"},{"location":"docs/lab2/lab2/#schnittstellenbeschreibung-abfrage-des-diebstahlstatus-bei-interpol","title":"Schnittstellenbeschreibung Abfrage des Diebstahlstatus bei Interpol","text":"Schnittstellenelement Dom\u00e4nenobjekte Parameter Vin R\u00fcckgabe TheftStatus"},{"location":"docs/lab2/lab2/#response-der-abfrage-des-diebstahlstatus","title":"Response der Abfrage des Diebstahlstatus","text":"<pre><code>public TheftStatusRequestResponse {\n    private String vin;\n    private boolean isStolen;\n}\n</code></pre>"},{"location":"docs/lab2/lab2/#methode-zur-ermittlung-des-registrierungsland-anhand-des-kennzeichens","title":"Methode zur Ermittlung des Registrierungsland anhand des Kennzeichens","text":"<p>Nutze diesen Domain Service, der viel Magie enth\u00e4lt, zur Ermittlung des Registrierungslandes anhand des Kennzeichens.</p> <pre><code>public class DetectRegistrationCountryService {\n\n    public CountryCode detect(LicensePlate licensePlate) {\n        return new CountryCode(\"DE\");\n    }\n}\n</code></pre>"},{"location":"docs/lab3/lab3/","title":"Aufgabe 3 Implementierung der Interface Adapters","text":""},{"location":"docs/lab3/lab3/#lernziele","title":"Lernziele","text":"<ul> <li>Meta-Stereotyp Interface Adapter verstehen</li> <li>Beispiele f\u00fcr Stereotypen von Interface Adapters verstehen und anwenden k\u00f6nnen</li> <li>Aufgaben und Konzepte des Interface Adapters Ring / Adapters Hexagon verstehen</li> </ul>"},{"location":"docs/lab3/lab3/#aufgabe-30-basisstruktur-des-interace-adapters-ring-anlegen","title":"Aufgabe 3.0 Basisstruktur des Interace Adapters Ring anlegen","text":"<ul> <li>Erstelle das Package vehicle.adapter.in</li> <li>Erstelle das Package vehicle.adapter.out</li> </ul>"},{"location":"docs/lab3/lab3/#aufgabe-31-implementierung-der-interface-adapters","title":"Aufgabe 3.1 Implementierung der Interface Adapters","text":"<p>Die Interface Adapters sollen die Integration der technischen Komponenten nur andeuten! Fokus liegt auf der Implementierung der Use Cases, der eingesetzten Designkonzepte und der Adaption mittels Mapping.</p> Anwendungsfall Eingehende Interface Adapter Technische Komponente Fahrzeug anlegen Controller Web Kilometerstand aktualisieren Controller Web Anwendungsfall Ausgehende Interface Adapter Technische Komponente Fahrzeug speichern Repository Datenbank Fahrzeug lesen Repository Datenbank Risikol\u00e4nder abfragen ServiceClient Externe REST API Abfrage Diebstahlstatus ServiceClient Externe REST API Abfrage Fahrzeugstammdaten ServiceClient Externe REST API <ul> <li>Implementiert die Interface Adapters und deren Datentransferobjekte f\u00fcr die Anwendungsf\u00e4lle Fahrzeug anlegen und Kilometerstand aktualisieren sowie die f\u00fcr die sich daraus ergebenden ausgehenden Anwendungsf\u00e4lle</li> <li>Verwende die Two-Way Mapping Strategie</li> <li>Implementiere keine Tests f\u00fcr die Interface Adapters</li> <li>Implementiere einen Test f\u00fcr einen Mapper deiner Wahl</li> </ul> <p>Optional:</p> <ul> <li>Wende die One-Way Mapping Strategie im Interface Adapter des Anwendungsfall \"Kilometerstand aktualisieren\" an<ul> <li>Was h\u00e4lst du davon? Wie empfindest du die Mischung der Strategien und Auswirkung auf die Dom\u00e4nenobjekte</li> </ul> </li> <li>Wende die No Mapping Strategie im Interface Adapter des Anwendungsfall \"Fahrzeug speichern\" und \"Fahrzeug lesen\" an<ul> <li>Was h\u00e4lst du davon? Wie empfindest du die Mischung der Strategien und Auswirkung auf die Dom\u00e4nenobjekte</li> </ul> </li> <li>Verwende MapStruct f\u00fcr die Implementierung eines Mappers deiner Wahl</li> </ul>"},{"location":"docs/lab3/lab3/#hilfestellung-fur-die-implementierung","title":"Hilfestellung f\u00fcr die Implementierung","text":""},{"location":"docs/lab3/lab3/#resource-model-der-rest-api","title":"Resource-Model der REST API","text":"<pre><code>public class VehicleResource {\n    private String vin;\n    private String licensePlate;\n    private List&lt;MileageRecordResource&gt; mileageRecords;\n    private VehicleMasterDataResource vehicleMasterData;\n\n    public VehicleMasterDataResource getVehicleMasterData() {\n        return vehicleMasterData;\n    }\n\n    public void setVehicleMasterData(VehicleMasterDataResource vehicleMasterData) {\n        this.vehicleMasterData = vehicleMasterData;\n    }\n    public String getVin() {\n        return vin;\n    }\n\n    public void setVin(String vin) {\n        this.vin = vin;\n    }\n\n    public String getLicensePlate() {\n        return licensePlate;\n    }\n\n    public void setLicensePlate(String licensePlate) {\n        this.licensePlate = licensePlate;\n    }\n\n    public List&lt;MileageRecordResource&gt; getMileageRecords() {\n        return mileageRecords;\n    }\n\n    public void setMileageRecords(List&lt;MileageRecordResource&gt; mileageRecords) {\n        this.mileageRecords = mileageRecords;\n    }\n}\n</code></pre> <pre><code>public class VehicleMasterDataResource {\n    private List&lt;EquipmentResource&gt; equipmentList;\n    private String countryOfManufacture;\n\n    public List&lt;EquipmentResource&gt; getEquipmentList() {\n        return equipmentList;\n    }\n\n    public void setEquipmentList(List&lt;EquipmentResource&gt; equipmentList) {\n        this.equipmentList = equipmentList;\n    }\n\n    public String getCountryOfManufacture() {\n        return countryOfManufacture;\n    }\n\n    public void setCountryOfManufacture(String countryOfManufacture) {\n        this.countryOfManufacture = countryOfManufacture;\n    }\n}\n</code></pre> <pre><code>public class MileageRecordResource {\n    private String recordDate;\n    private Double mileage;\n\n    public String getRecordDate() {\n        return recordDate;\n    }\n\n    public void setRecordDate(String recordDate) {\n        this.recordDate = recordDate;\n    }\n\n    public Double getMileage() {\n        return mileage;\n    }\n</code></pre> <pre><code>public class EquipmentResource {\n\n    private String equipmentCode;\n    private String equipmentLabel;\n\n    public String getEquipmentCode() {\n        return equipmentCode;\n    }\n\n    public void setEquipmentCode(String equipmentCode) {\n        this.equipmentCode = equipmentCode;\n    }\n\n    public String getEquipmentLabel() {\n        return equipmentLabel;\n    }\n\n    public void setEquipmentLabel(String equipmentLabel) {\n        this.equipmentLabel = equipmentLabel;\n    }\n}\n</code></pre>"},{"location":"docs/lab3/lab3/#das-domanenmodell-in-der-datenbank","title":"Das Dom\u00e4nenmodell in der Datenbank","text":"<pre><code>public class VehicleDbEntity {\n\n    private String vin;\n    private String licensePlate;\n    private List&lt;MileageRecordDbEntity&gt; mileageRecords;\n    private List&lt;EquipmentDbEntity&gt; equipmentList;\n\n    public String getVin() {\n        return vin;\n    }\n\n    public void setVin(String vin) {\n        this.vin = vin;\n    }\n\n    public String getLicensePlate() {\n        return licensePlate;\n    }\n\n    public void setLicensePlate(String licensePlate) {\n        this.licensePlate = licensePlate;\n    }\n\n    public List&lt;MileageRecord&gt; getMileageRecords() {\n        return mileageRecords;\n    }\n\n    public void setMileageRecords(List&lt;MileageRecord&gt; mileageRecords) {\n        this.mileageRecords = mileageRecords;\n    }\n\n    public List&lt;EquipmentDbEntity&gt; getEquipmentList() {\n        return equipmentList;\n    }\n\n    public void setEquipmentList(List&lt;EquipmentDbEntity&gt; equipmentList) {\n        this.equipmentList = equipmentList;\n    }\n}\n</code></pre> <pre><code>public class EquipmentDbEntity {\n    private String equipmentCode;\n    private String equipmentLabel;\n\n    public String getEquipmentCode() {\n        return equipmentCode;\n    }\n\n    public void setEquipmentCode(String equipmentCode) {\n        this.equipmentCode = equipmentCode;\n    }\n\n    public String getEquipmentLabel() {\n        return equipmentLabel;\n    }\n\n    public void setEquipmentLabel(String equipmentLabel) {\n        this.equipmentLabel = equipmentLabel;\n    }\n}\n</code></pre> <pre><code>public class MileageRecordDbEntity {\n    private double mileage;\n    private String recordTime;\n\n    public double getMileage() {\n        return mileage;\n    }\n\n    public void setMileage(double mileage) {\n        this.mileage = mileage;\n    }\n\n    public String getRecordTime() {\n        return recordTime;\n    }\n\n    public void setRecordTime(String recordTime) {\n        this.recordTime = recordTime;\n    }\n}\n</code></pre>"},{"location":"docs/lab3/lab3/#32-analysiere-den-einsatz-von-mapping-frameworks","title":"3.2 Analysiere den Einsatz von Mapping-Frameworks","text":"<ul> <li>Welche Mapping-Frameworks gibt es?</li> <li>Welche Vor- und Nachteile haben die Frameworks?</li> <li>Object-to-object mapping framework microbenchmark</li> </ul>"},{"location":"docs/lab4/lab4/","title":"Aufgabe 4 Weitere Anwendungsf\u00e4lle der Root Entity Vehicle","text":""},{"location":"docs/lab4/lab4/#lernziele","title":"Lernziele","text":"<ul> <li>Strategien f\u00fcr den Use-Case-Schnitt verstehen und anwenden k\u00f6nnen</li> <li>Erfahren, wie das Modul in der Clean Architecture w\u00e4chst und erweitert wird</li> </ul>"},{"location":"docs/lab4/lab4/#aufgabe-40-mapping-strategie","title":"Aufgabe 4.0 Mapping Strategie","text":"<ul> <li>Verwende die Two-Way oder One-Way Mapping Strategie f\u00fcr das Mapping zwischen den Datentransferobjekten und den Dom\u00e4nenobjekten</li> <li>Betrachte beide Aufgaben und entscheide dich f\u00fcr einen Use-Case-Schnitt. Halte in Stichworten fest, wieso du dich f\u00fcr diesen Schnitt entschieden hast.</li> </ul>"},{"location":"docs/lab4/lab4/#aufgabe-41-anwendungsfall-fahrzeug-lesen-fur-das-eigene-frontend","title":"Aufgabe 4.1 Anwendungsfall Fahrzeug lesen f\u00fcr das eigene Frontend","text":"<ul> <li>Das Frontend ben\u00f6tigt Fahrzeugdaten f\u00fcr die Anzeige</li> <li>Implementiere den Anwendungsfall mit Use Cases, Interactor, Interfaces Adapters, Mappings und Datentransferobjekten</li> </ul>"},{"location":"docs/lab4/lab4/#schnittstellenbeschreibung-anwendungsfall-fahrzeug-lesen","title":"Schnittstellenbeschreibung Anwendungsfall Fahrzeug lesen","text":"Schnittstellenelement Dom\u00e4nenobjekte Parameter Vin R\u00fcckgabe Vehicle"},{"location":"docs/lab4/lab4/#ablauf-des-anwendungsfalls","title":"Ablauf des Anwendungsfalls","text":"<ul> <li>Abfrage des Fahrzeugs anhand der Vin</li> </ul>"},{"location":"docs/lab4/lab4/#aufgabe-42-anwendungsfall-fahrzeugstammdaten-lesen-fur-externe-konsumenten","title":"Aufgabe 4.2 Anwendungsfall Fahrzeugstammdaten lesen f\u00fcr externe Konsumenten","text":"<ul> <li>Das System Ersatzteileverwaltung (Spare Parts Management) ben\u00f6tigt Fahrzeugstammdaten f\u00fcr Ersatzteilefindung und -bestellung.</li> <li>Implementiere den Anwendungsfall mit Use Cases, Interactor, Interfaces Adapters, Mappings und</li> </ul>"},{"location":"docs/lab4/lab4/#schnittstellenbeschreibung-fahrzeugstammdaten-lesen","title":"Schnittstellenbeschreibung Fahrzeugstammdaten lesen","text":"Schnittstellenelement Dom\u00e4nenobjekte Parameter Vin R\u00fcckgabe Vehicle Master Data"},{"location":"docs/lab4/lab4/#ablauf-des-anwendungsfalls_1","title":"Ablauf des Anwendungsfalls","text":"<ul> <li>Abfrage der Fahrzeugstammdaten anhand der Vin</li> </ul>"},{"location":"docs/lab5/lab5/","title":"Aufgabe 5 Fachliche Modularisierung anhand Root Entities","text":""},{"location":"docs/lab5/lab5/#lernziele","title":"Lernziele","text":"<ul> <li>Fachliche Modularisierung anhand von Root Entities verstehen und anwenden k\u00f6nnen</li> <li>Erfahren, wie das System in der Clean Architecture w\u00e4chst und erweitert wird</li> <li>Strategien f\u00fcr die Behandlung von Abh\u00e4ngigkeiten zwischen Root Entities verstehen</li> </ul>"},{"location":"docs/lab5/lab5/#aufgabe-50-fachliche-modularisierung","title":"Aufgabe 5.0 Fachliche Modularisierung","text":"<ul> <li>Betrachte die Module GarageOrder und SpareParts</li> </ul>"},{"location":"docs/lab5/lab5/#aufgabe-51-anwendungsfall-werkstattauftrag-anlegen","title":"Aufgabe 5.1 Anwendungsfall Werkstattauftrag anlegen","text":"<ul> <li>F\u00fcr die Anlage eines Werkstattauftrags im Modul GarageOrder werden die Vin,  das Kennzeichen (LicensePlate) und der aktuelle Kilometerstand (Mileage) des Fahrzeugs ben\u00f6tigt</li> <li>Die Abfrage muss anhand des Kennzeichens oder der Fahrgestellnummer m\u00f6glich sein</li> <li>Implementiere ein Muster deiner Wahl, um die Abh\u00e4ngigkeit zwischen dem Domain Module  GarageOrder und dem Domain Module  Vehicle zu implementieren</li> </ul>"},{"location":"docs/lab5/lab5/#schnittstellenbeschreibung-fahrzeugdaten-abfragen","title":"Schnittstellenbeschreibung Fahrzeugdaten abfragen","text":"Schnittstellenelement Dom\u00e4nenobjekte Parameter Vin R\u00fcckgabe VehicleData Schnittstellenelement Dom\u00e4nenobjekte Parameter LicensePlate R\u00fcckgabe VehicleData"},{"location":"docs/lab5/lab5/#fahrzeugdaten-die-im-werkstattauftrag-benotigt-werden","title":"Fahrzeugdaten die im Werkstattauftrag ben\u00f6tigt werden","text":"<pre><code>VehicleData {\n    licensePlate: String\n    vin: String\n    mileage: double        \n}\n</code></pre>"},{"location":"docs/lab5/lab5/#aufgabe-52-anwendungsfall-fahrzeugstammdaten-abfragen","title":"Aufgabe 5.2 Anwendungsfall Fahrzeugstammdaten abfragen","text":"<ul> <li>Die Ersatzteileverwaltung (Modul SpareParts) ben\u00f6tigt Fahrzeugstammdaten</li> <li>Die Abfrage muss anhand der Fahrgestellnummer m\u00f6glich sein</li> <li>Implementiere ein Muster deiner Wahl, um die Abh\u00e4ngigkeit zwischen dem Domain Module   SpareParts und dem Domain Module Vehicle zu implementieren</li> </ul>"},{"location":"docs/lab5/lab5/#schnittstellenbeschreibung","title":"Schnittstellenbeschreibung","text":"Schnittstellenelement Dom\u00e4nenobjekte Parameter Vin R\u00fcckgabe VehicleMasterData"},{"location":"docs/lab5/lab5/#aufgabe-53-weitere-muster-fur-abhangigkeiten-zwischen-domain-modules","title":"Aufgabe 5.3 Weitere Muster f\u00fcr Abh\u00e4ngigkeiten zwischen Domain Modules","text":"<ul> <li>Diskutiere in der Gruppe oder analysiere f\u00fcr dich, wann ein Shared Output Adapter Pattern oder Supporting Service Pattern eine gute alternative sein kann</li> </ul> <p>Optional: - Implementiere die Szenarien 5.1 und 5.2 mit einem  Shared Output Adapter Pattern - Implementiere die Szenarien 5.1 und 5.2 mit einem Supporting Service Pattern</p>"},{"location":"docs/lab6/lab6/","title":"Aufgabe 6 Automatisierte Governance mittels Fitness Functions","text":""},{"location":"docs/lab6/lab6/#lernziele","title":"Lernziele","text":"<ul> <li>Strukturtest in der Clean Architecture verstehen und anwenden</li> <li>ArchUnit als leichtgewichtiges Tool f\u00fcr Fitness Functions der strukturellen Qualit\u00e4t</li> </ul>"},{"location":"docs/lab6/lab6/#aufgabe-61-archunit-clean-architecture-template","title":"Aufgabe 6.1 ArchUnit Clean Architecture Template","text":"<p>Binde folgenden Code, ohne in verstehen zu wollen, in dein Projekt ein:</p> <pre><code>import com.tngtech.archunit.PublicAPI;\nimport com.tngtech.archunit.base.DescribedPredicate;\nimport com.tngtech.archunit.core.domain.JavaClass;\nimport com.tngtech.archunit.core.domain.JavaClasses;\nimport com.tngtech.archunit.lang.ArchRule;\nimport com.tngtech.archunit.lang.EvaluationResult;\nimport com.tngtech.archunit.library.Architectures;\n\nimport java.util.*;\n\npublic final class CleanArchitecture implements ArchRule {\n\n    private static final String DOMAIN_MODEL = \"domain.model\";\n    private static final String DOMAIN_SERVICE = \"domain.service\";\n    private static final String USECASE_INTERACTOR = \"usecase.interactor\";\n    private static final String ADAPTER_OUT = \"adapter.out\";\n    private static final String ADAPTER_IN = \"adapter.in\";\n    private static final String USECASE_IN = \"usecase.in\";\n    private static final String USECASE_OUT = \"usecase.out\";\n    private static final String DOMAIN = \"domain\";\n    private static final String USECASE = \"usecase\";\n    private static final String ADAPTER = \"adapter\";\n    public static final String IGNORED_PACKAGES = \"ignored.packages\";\n    //dependency patterns\n    private static final String SHARED_KERNEL_PATTERN = \"shared.kernel\";\n    private static final String SHARED_OUTPUT_ADAPTER_PATTERN = \"shared.output.adapter\";\n    private static final String SUPPORTING_SERVICE_PATTERN = \"supporting.service\";\n    private static final String EVENTS_PATTERN = \"events\";\n    private static final String ADAPTER_OUT_OF_ADAPTER_OUT_USE_CASE_IN_PATTERN = \"adapter.out.usecase.in\";\n    private static final String APPLICATION_SERVICE_PATTERN = \"application.service\";\n    private Optional&lt;String&gt; overriddenDescription;\n\n    private String domainModelPackageIdentifier;\n    private String domainServicePackageIdentifier;\n    private String usecaseInteractorPackageIdentifier;\n    private String adapterInPackageIdentifier;\n    private String adapterOutPackageIdentifier;\n    private String useCaseInPackageIdentifier;\n    private String useCaseOutPackageIdentifier;\n\n    private String useCasePackageIdentifier;\n    private String adapterPackageIdentifier;\n    private String domainPackageIdentifier;\n    private Map&lt;String, String&gt; adapterPackageIdentifiers;\n\n    //dependency\n    private List&lt;String&gt; sharedOutputAdapter;\n    private List&lt;String&gt; supportingService;\n    private List&lt;String&gt; sharedKernel;\n    private List&lt;String&gt; events;\n    private List&lt;String&gt; applicationService;\n\n    private boolean optionalLayers;\n\n    //check styles\n    private boolean allRingsDeepCheck;\n    private List&lt;IgnoredDependency&gt; ignoredDependencies;\n    private List&lt;String&gt; ignoredPackageIdentifiers;\n    private List&lt;String&gt; adapterOutOfAdapterOutUseCaseIn;\n\n    //clean arc pattern template\n    private CleanArchitectureCheck check;\n\n    private CleanArchitecture(CleanArchitectureCheck check) {\n        this.check = check;\n        this.domainModelPackageIdentifier = DOMAIN_MODEL;\n        this.domainServicePackageIdentifier = DOMAIN_SERVICE;\n        this.usecaseInteractorPackageIdentifier = USECASE_INTERACTOR;\n        this.adapterInPackageIdentifier = ADAPTER_IN;\n        this.adapterOutPackageIdentifier = ADAPTER_OUT;\n        this.useCaseInPackageIdentifier = USECASE_IN;\n        this.useCaseOutPackageIdentifier = USECASE_OUT;\n        this.useCasePackageIdentifier = USECASE;\n        this.domainPackageIdentifier = DOMAIN;\n        this.adapterPackageIdentifier = ADAPTER;\n        this.adapterPackageIdentifiers = new LinkedHashMap&lt;&gt;();\n        this.optionalLayers = true;\n        this.ignoredDependencies = new ArrayList();\n        this.overriddenDescription = Optional.empty();\n        this.ignoredPackageIdentifiers = new ArrayList&lt;&gt;();\n        this.sharedOutputAdapter = new ArrayList&lt;&gt;();\n        this.supportingService = new ArrayList&lt;&gt;();\n        this.events = new ArrayList&lt;&gt;();\n        this.applicationService = new ArrayList&lt;&gt;();\n        this.adapterOutOfAdapterOutUseCaseIn = new ArrayList&lt;&gt;();\n        this.sharedKernel = new ArrayList&lt;&gt;();\n    }\n\n    private CleanArchitecture(CleanArchitectureCheck check,\n                              Optional&lt;String&gt; overriddenDescription,\n                              String domainModelPackageIdentifier,\n                              String domainServicePackageIdentifier,\n                              String usecaseInteractorPackageIdentifier,\n                              String adapterInPackageIdentifier,\n                              String adapterOutPackageIdentifier,\n                              String useCaseInPackageIdentifier,\n                              String useCaseOutPackageIdentifier,\n                              String useCasePackageIdentifier,\n                              String adapterPackageIdentifier,\n                              String domainPackageIdentifier,\n                              Map&lt;String, String&gt; adapterPackageIdentifiers,\n                              boolean optionalLayers,\n                              boolean allRingsDeepCheck,\n                              List&lt;IgnoredDependency&gt; ignoredDependencies,\n                              List&lt;String&gt; sharedOutputAdapter,\n                              List&lt;String&gt; ignoredPackageIdentifiers,\n                              List&lt;String&gt; supportingService,\n                              List&lt;String&gt; adapterOutOfAdapterOutUseCaseIn,\n                              List&lt;String&gt; sharedKernel) {\n        this(check);\n        this.overriddenDescription = overriddenDescription;\n        this.domainModelPackageIdentifier = domainModelPackageIdentifier;\n        this.domainServicePackageIdentifier = domainServicePackageIdentifier;\n        this.usecaseInteractorPackageIdentifier = usecaseInteractorPackageIdentifier;\n        this.adapterInPackageIdentifier = adapterInPackageIdentifier;\n        this.adapterOutPackageIdentifier = adapterOutPackageIdentifier;\n        this.useCaseInPackageIdentifier = useCaseInPackageIdentifier;\n        this.useCaseOutPackageIdentifier = useCaseOutPackageIdentifier;\n        this.useCasePackageIdentifier = useCasePackageIdentifier;\n        this.adapterPackageIdentifier = adapterPackageIdentifier;\n        this.domainPackageIdentifier = domainPackageIdentifier;\n        this.adapterPackageIdentifiers = adapterPackageIdentifiers;\n        this.optionalLayers = optionalLayers;\n        this.allRingsDeepCheck = allRingsDeepCheck;\n        this.ignoredDependencies = ignoredDependencies;\n        this.sharedOutputAdapter = sharedOutputAdapter;\n        this.ignoredPackageIdentifiers = ignoredPackageIdentifiers;\n        this.supportingService = supportingService;\n        this.adapterOutOfAdapterOutUseCaseIn = adapterOutOfAdapterOutUseCaseIn;\n        this.sharedKernel = sharedKernel;\n    }\n\n    public static CleanArchitecture cleanArchitecture(CleanArchitectureCheck check) {\n        return new CleanArchitecture(check);\n    }\n\n    @PublicAPI(usage = PublicAPI.Usage.ACCESS)\n    public CleanArchitecture domainModel(String packageIdentifier) {\n        this.domainModelPackageIdentifier = packageIdentifier;\n        return this;\n    }\n\n    @PublicAPI(usage = PublicAPI.Usage.ACCESS)\n    public CleanArchitecture domainService(String packageIdentifier) {\n        this.domainServicePackageIdentifier = packageIdentifier;\n        return this;\n    }\n\n    @PublicAPI(usage = PublicAPI.Usage.ACCESS)\n    public CleanArchitecture usecaseInteractor(String packageIdentifier) {\n        this.usecaseInteractorPackageIdentifier = packageIdentifier;\n        return this;\n    }\n\n    @PublicAPI(usage = PublicAPI.Usage.ACCESS)\n    public CleanArchitecture adapterIn(String packageIdentifier) {\n        this.adapterInPackageIdentifier = packageIdentifier;\n        return this;\n    }\n\n    @PublicAPI(usage = PublicAPI.Usage.ACCESS)\n    public CleanArchitecture adapterOut(String packageIdentifier) {\n        this.adapterOutPackageIdentifier = packageIdentifier;\n        return this;\n    }\n\n    @PublicAPI(usage = PublicAPI.Usage.ACCESS)\n    public CleanArchitecture useCaseIn(String packageIdentifier) {\n        this.useCaseInPackageIdentifier = packageIdentifier;\n        return this;\n    }\n\n    @PublicAPI(usage = PublicAPI.Usage.ACCESS)\n    public CleanArchitecture useCaseOut(String packageIdentifier) {\n        this.useCaseOutPackageIdentifier = packageIdentifier;\n        return this;\n    }\n\n    @PublicAPI(usage = PublicAPI.Usage.ACCESS)\n    public CleanArchitecture useCase(String packageIdentifier) {\n        this.useCasePackageIdentifier = packageIdentifier;\n        return this;\n    }\n\n    @PublicAPI(usage = PublicAPI.Usage.ACCESS)\n    public CleanArchitecture adapter(String packageIdentifier) {\n        this.adapterPackageIdentifier = packageIdentifier;\n        return this;\n    }\n\n    @PublicAPI(usage = PublicAPI.Usage.ACCESS)\n    public CleanArchitecture domain(String packageIdentifier) {\n        this.domainPackageIdentifier = packageIdentifier;\n        return this;\n    }\n\n    @PublicAPI(usage = PublicAPI.Usage.ACCESS)\n    public CleanArchitecture adapter(String name, String packageIdentifier) {\n        this.adapterPackageIdentifiers.put(name, packageIdentifier);\n        return this;\n    }\n\n    @PublicAPI(\n            usage = PublicAPI.Usage.ACCESS\n    )\n    public CleanArchitecture supportingService(String... packageIdentifier) {\n        this.supportingService = List.of(packageIdentifier);\n        return this;\n    }\n\n    @PublicAPI(\n            usage = PublicAPI.Usage.ACCESS\n    )\n    public CleanArchitecture sharedOutputAdapter(String... packageIdentifier) {\n        this.sharedOutputAdapter = List.of(packageIdentifier);\n        return this;\n    }\n\n    @PublicAPI(\n            usage = PublicAPI.Usage.ACCESS\n    )\n    public CleanArchitecture sharedKernel(String... packageIdentifier) {\n        this.sharedKernel = List.of(packageIdentifier);\n        return this;\n    }\n\n    @PublicAPI(\n            usage = PublicAPI.Usage.ACCESS\n    )\n    public CleanArchitecture ignore(String... packageIdentifier) {\n        this.ignoredPackageIdentifiers = List.of(packageIdentifier);\n        return this;\n    }\n\n    @PublicAPI(\n            usage = PublicAPI.Usage.ACCESS\n    )\n    public CleanArchitecture adapterOutOfAdapterOutUseCaseIn(String... packageIdentifier) {\n        this.adapterOutOfAdapterOutUseCaseIn = List.of(packageIdentifier);\n        return this;\n    }\n\n    @PublicAPI(\n            usage = PublicAPI.Usage.ACCESS\n    )\n    public CleanArchitecture applicationService(String... packageIdentifier) {\n        this.applicationService = List.of(packageIdentifier);\n        return this;\n    }\n\n    @PublicAPI(\n            usage = PublicAPI.Usage.ACCESS\n    )\n    public CleanArchitecture events(String... packageIdentifier) {\n        this.events = List.of(packageIdentifier);\n        return this;\n    }\n\n    @PublicAPI(usage = PublicAPI.Usage.ACCESS)\n    public CleanArchitecture ignoreDependency(Class&lt;?&gt; origin, Class&lt;?&gt; target) {\n        return this.ignoreDependency(JavaClass.Predicates.equivalentTo(origin), JavaClass.Predicates.equivalentTo(target));\n    }\n\n    @PublicAPI(\n            usage = PublicAPI.Usage.ACCESS\n    )\n    public CleanArchitecture ignoreDependency(String origin, String target) {\n        return this.ignoreDependency(com.tngtech.archunit.core.domain.properties.HasName.Predicates.name(origin), com.tngtech.archunit.core.domain.properties.HasName.Predicates.name(target));\n    }\n\n    @PublicAPI(\n            usage = PublicAPI.Usage.ACCESS\n    )\n    public CleanArchitecture ignoreDependency(DescribedPredicate&lt;? super JavaClass&gt; origin, DescribedPredicate&lt;? super JavaClass&gt; target) {\n        this.ignoredDependencies.add(new IgnoredDependency(origin, target));\n        return this;\n    }\n\n    private Architectures.LayeredArchitecture layeredArchitectureDelegate() {\n        if (this.check == CleanArchitectureCheck.RINGS_AS_LAYERS) {\n            return ringsAsLayers();\n        } else if (this.check == CleanArchitectureCheck.DOMAIN_AND_USECASE_RING_ARCHITECTURAL_EXPRESSIVE) {\n            return domainRingAndUseCaseRingArchitecturalExpressive();\n        } else if (this.check == CleanArchitectureCheck.DOMAIN_RING_ARCHITECTURAL_EXPRESSIVE) {\n            return domainRingArchitecturalExpressive();\n        } else {\n            return allRingsArchitecturalExpressive();\n        }\n    }\n\n    private Architectures.LayeredArchitecture allRingsArchitecturalExpressive() {\n        Architectures.LayeredArchitecture layeredArchitectureDelegate = Architectures.layeredArchitecture()\n                .consideringAllDependencies()\n                .layer(DOMAIN_MODEL).definedBy(this.domainModelPackageIdentifier)\n                .layer(DOMAIN_SERVICE).definedBy(this.domainServicePackageIdentifier)\n                .layer(USECASE_INTERACTOR).definedBy(this.usecaseInteractorPackageIdentifier)\n                .layer(ADAPTER_IN).definedBy(this.adapterInPackageIdentifier)\n                .layer(ADAPTER_OUT).definedBy(this.adapterOutPackageIdentifier)\n                .layer(USECASE_IN).definedBy(this.useCaseInPackageIdentifier)\n                .layer(USECASE_OUT).definedBy(this.useCaseOutPackageIdentifier)\n                .optionalLayer(SHARED_OUTPUT_ADAPTER_PATTERN).definedBy(sharedOutputAdapter.toArray(new String[0]))\n                .optionalLayer(SUPPORTING_SERVICE_PATTERN).definedBy(supportingService.toArray(new String[0]))\n                .optionalLayer(SHARED_KERNEL_PATTERN).definedBy(sharedKernel.toArray(new String[0]))\n                .optionalLayer(ADAPTER_OUT_OF_ADAPTER_OUT_USE_CASE_IN_PATTERN).definedBy(adapterOutOfAdapterOutUseCaseIn.toArray(new String[0]))\n                .optionalLayer(EVENTS_PATTERN).definedBy(events.toArray(new String[0]))\n                .optionalLayer(APPLICATION_SERVICE_PATTERN).definedBy(applicationService.toArray(new String[0]))\n                .optionalLayer(IGNORED_PACKAGES).definedBy(ignoredPackageIdentifiers.toArray(new String[0]))\n                .whereLayer(DOMAIN_MODEL).mayOnlyBeAccessedByLayers(\n                        DOMAIN_SERVICE,\n                        USECASE_OUT,\n                        USECASE_IN,\n                        ADAPTER_IN,\n                        ADAPTER_OUT,\n                        USECASE_INTERACTOR,\n                        IGNORED_PACKAGES\n                )\n                .whereLayer(DOMAIN_SERVICE).mayOnlyBeAccessedByLayers(\n                        USECASE_INTERACTOR,\n                        IGNORED_PACKAGES\n                )\n                .whereLayer(USECASE_INTERACTOR).mayOnlyBeAccessedByLayers(\n                        USECASE_IN,\n                        USECASE_OUT,\n                        ADAPTER_IN, //erlaubt auch direkte Nutzung des Interactor ohne Use Case =&gt; Full Mapping\n                        ADAPTER_OUT, //erlaubt Nutzung eines Interactors, was nicht sinnvoll ist =&gt; Full Mapping\n                        IGNORED_PACKAGES\n                )\n                .whereLayer(ADAPTER_IN).mayOnlyBeAccessedByLayers(\n                        IGNORED_PACKAGES\n                )\n                .whereLayer(ADAPTER_OUT).mayOnlyBeAccessedByLayers(\n                        IGNORED_PACKAGES\n                )\n                .whereLayer(USECASE_IN).mayOnlyBeAccessedByLayers(\n                        ADAPTER_IN,\n                        USECASE_INTERACTOR,\n                        IGNORED_PACKAGES,\n                        ADAPTER_OUT_OF_ADAPTER_OUT_USE_CASE_IN_PATTERN,\n                        EVENTS_PATTERN,\n                        APPLICATION_SERVICE_PATTERN\n                )\n                .whereLayer(USECASE_OUT).mayOnlyBeAccessedByLayers(\n                        ADAPTER_OUT,\n                        USECASE_INTERACTOR,\n                        SHARED_OUTPUT_ADAPTER_PATTERN,\n                        IGNORED_PACKAGES\n                )\n                .whereLayer(SHARED_OUTPUT_ADAPTER_PATTERN).mayOnlyBeAccessedByLayers(\n                        IGNORED_PACKAGES\n                )\n                .whereLayer(SUPPORTING_SERVICE_PATTERN).mayOnlyBeAccessedByLayers(\n                        USECASE_INTERACTOR,\n                        DOMAIN_SERVICE,\n                        IGNORED_PACKAGES\n                )\n                .whereLayer(SHARED_KERNEL_PATTERN).mayOnlyBeAccessedByLayers(\n                        DOMAIN_SERVICE,\n                        USECASE_OUT,\n                        USECASE_IN,\n                        ADAPTER_IN,\n                        ADAPTER_OUT,\n                        USECASE_INTERACTOR,\n                        DOMAIN_MODEL\n                )\n                .withOptionalLayers(true);\n\n        return layeredArchitectureDelegate.as(this.getDescription());\n    }\n\n    private Architectures.LayeredArchitecture domainRingAndUseCaseRingArchitecturalExpressive() {\n        Architectures.LayeredArchitecture layeredArchitectureDelegate = Architectures.layeredArchitecture()\n                .consideringOnlyDependenciesInLayers()\n                .layer(DOMAIN_MODEL).definedBy(this.domainModelPackageIdentifier)\n                .layer(DOMAIN_SERVICE).definedBy(this.domainServicePackageIdentifier)\n                .optionalLayer(USECASE_INTERACTOR).definedBy(this.usecaseInteractorPackageIdentifier)\n                .layer(USECASE_IN).definedBy(this.useCaseInPackageIdentifier)\n                .layer(USECASE_OUT).definedBy(this.useCaseOutPackageIdentifier)\n                .layer(ADAPTER).definedBy(this.adapterPackageIdentifier)\n                .optionalLayer(IGNORED_PACKAGES).definedBy(ignoredPackageIdentifiers.toArray(new String[0]))\n                .optionalLayer(SHARED_KERNEL_PATTERN).definedBy(sharedKernel.toArray(new String[0]))\n                .optionalLayer(SHARED_OUTPUT_ADAPTER_PATTERN).definedBy(sharedOutputAdapter.toArray(new String[0]))\n                .optionalLayer(ADAPTER_OUT_OF_ADAPTER_OUT_USE_CASE_IN_PATTERN).definedBy(adapterOutOfAdapterOutUseCaseIn.toArray(new String[0]))\n                .optionalLayer(EVENTS_PATTERN).definedBy(events.toArray(new String[0]))\n                .optionalLayer(SUPPORTING_SERVICE_PATTERN).definedBy(supportingService.toArray(new String[0]))\n                .optionalLayer(ADAPTER_OUT_OF_ADAPTER_OUT_USE_CASE_IN_PATTERN).definedBy(adapterOutOfAdapterOutUseCaseIn.toArray(new String[0]))\n                .whereLayer(DOMAIN_MODEL).mayOnlyBeAccessedByLayers(\n                        DOMAIN_SERVICE,\n                        USECASE_OUT,\n                        USECASE_IN,\n                        ADAPTER,\n                        USECASE_INTERACTOR,\n                        IGNORED_PACKAGES,\n                        SHARED_OUTPUT_ADAPTER_PATTERN\n                )\n                .whereLayer(DOMAIN_SERVICE).mayOnlyBeAccessedByLayers(\n                        USECASE_INTERACTOR,\n                        IGNORED_PACKAGES\n                )\n                .whereLayer(USECASE_INTERACTOR).mayOnlyBeAccessedByLayers(\n                        USECASE_IN,\n                        USECASE_OUT,\n                        ADAPTER_IN,\n                        ADAPTER_OUT,\n                        IGNORED_PACKAGES\n                )\n                .whereLayer(USECASE_IN).mayOnlyBeAccessedByLayers(\n                        ADAPTER,\n                        USECASE_INTERACTOR,\n                        DOMAIN_SERVICE,\n                        IGNORED_PACKAGES,\n                        ADAPTER_OUT_OF_ADAPTER_OUT_USE_CASE_IN_PATTERN,\n                        EVENTS_PATTERN,\n                        APPLICATION_SERVICE_PATTERN\n                )\n                .whereLayer(USECASE_OUT).mayOnlyBeAccessedByLayers(\n                        ADAPTER,\n                        DOMAIN_SERVICE,\n                        USECASE_INTERACTOR,\n                        SHARED_OUTPUT_ADAPTER_PATTERN,\n                        IGNORED_PACKAGES\n                )\n                .whereLayer(SHARED_OUTPUT_ADAPTER_PATTERN).mayOnlyBeAccessedByLayers(\n                        IGNORED_PACKAGES\n                )\n                .whereLayer(SUPPORTING_SERVICE_PATTERN).mayOnlyBeAccessedByLayers(\n                        USECASE_INTERACTOR,\n                        DOMAIN_SERVICE,\n                        IGNORED_PACKAGES\n                )\n                .whereLayer(SHARED_KERNEL_PATTERN).mayOnlyBeAccessedByLayers(\n                        DOMAIN_SERVICE,\n                        USECASE_OUT,\n                        USECASE_IN,\n                        ADAPTER,\n                        USECASE_INTERACTOR,\n                        DOMAIN_MODEL,\n                        IGNORED_PACKAGES\n                )\n                .withOptionalLayers(true);\n\n        return layeredArchitectureDelegate.as(this.getDescription());\n    }\n\n    private Architectures.LayeredArchitecture domainRingArchitecturalExpressive() {\n        Architectures.LayeredArchitecture layeredArchitectureDelegate = Architectures.layeredArchitecture()\n                .consideringOnlyDependenciesInLayers()\n                .layer(DOMAIN_MODEL).definedBy(this.domainModelPackageIdentifier)\n                .layer(DOMAIN_SERVICE).definedBy(this.domainServicePackageIdentifier)\n                .layer(ADAPTER).definedBy(this.adapterPackageIdentifier)\n                .optionalLayer(USECASE_INTERACTOR).definedBy(this.usecaseInteractorPackageIdentifier)\n                .layer(USECASE).definedBy(this.useCasePackageIdentifier)\n                .optionalLayer(IGNORED_PACKAGES).definedBy(ignoredPackageIdentifiers.toArray(new String[0]))\n                .optionalLayer(SHARED_KERNEL_PATTERN).definedBy(sharedKernel.toArray(new String[0]))\n                .optionalLayer(SHARED_OUTPUT_ADAPTER_PATTERN).definedBy(sharedOutputAdapter.toArray(new String[0]))\n                .optionalLayer(ADAPTER_OUT_OF_ADAPTER_OUT_USE_CASE_IN_PATTERN).definedBy(adapterOutOfAdapterOutUseCaseIn.toArray(new String[0]))\n                .optionalLayer(EVENTS_PATTERN).definedBy(events.toArray(new String[0]))\n                .optionalLayer(SUPPORTING_SERVICE_PATTERN).definedBy(supportingService.toArray(new String[0]))\n                .optionalLayer(ADAPTER_OUT_OF_ADAPTER_OUT_USE_CASE_IN_PATTERN).definedBy(adapterOutOfAdapterOutUseCaseIn.toArray(new String[0]))\n                .whereLayer(DOMAIN_MODEL).mayOnlyBeAccessedByLayers(\n                        DOMAIN_SERVICE,\n                        USECASE,\n                        ADAPTER,\n                        USECASE_INTERACTOR,\n                        IGNORED_PACKAGES,\n                        SHARED_OUTPUT_ADAPTER_PATTERN\n                )\n                .whereLayer(DOMAIN_SERVICE).mayOnlyBeAccessedByLayers(\n                        USECASE_INTERACTOR,\n                        IGNORED_PACKAGES\n                )\n                .whereLayer(SHARED_OUTPUT_ADAPTER_PATTERN).mayOnlyBeAccessedByLayers(\n                        USECASE,\n                        DOMAIN_MODEL,\n                        IGNORED_PACKAGES\n                )\n                .whereLayer(USECASE_INTERACTOR).mayOnlyBeAccessedByLayers(\n                        USECASE,\n                        ADAPTER,\n                        IGNORED_PACKAGES\n                )\n                .whereLayer(USECASE).mayOnlyBeAccessedByLayers(\n                        ADAPTER,\n                        USECASE_INTERACTOR,\n                        DOMAIN_SERVICE,\n                        IGNORED_PACKAGES,\n                        ADAPTER_OUT_OF_ADAPTER_OUT_USE_CASE_IN_PATTERN,\n                        SHARED_OUTPUT_ADAPTER_PATTERN,\n                        EVENTS_PATTERN,\n                        APPLICATION_SERVICE_PATTERN\n                )\n                .whereLayer(SHARED_OUTPUT_ADAPTER_PATTERN).mayOnlyBeAccessedByLayers(\n                        USECASE,\n                        DOMAIN_MODEL,\n                        IGNORED_PACKAGES\n                )\n                .whereLayer(SUPPORTING_SERVICE_PATTERN).mayOnlyBeAccessedByLayers(\n                        USECASE_INTERACTOR,\n                        DOMAIN_SERVICE,\n                        IGNORED_PACKAGES\n                )\n                .whereLayer(SHARED_KERNEL_PATTERN).mayOnlyBeAccessedByLayers(\n                        DOMAIN_SERVICE,\n                        USECASE,\n                        ADAPTER,\n                        USECASE_INTERACTOR,\n                        DOMAIN_MODEL,\n                        IGNORED_PACKAGES\n                )\n                .withOptionalLayers(true);\n\n        return layeredArchitectureDelegate.as(this.getDescription());\n    }\n\n    private Architectures.LayeredArchitecture ringsAsLayers() {\n        Architectures.LayeredArchitecture layeredArchitectureDelegate = Architectures.layeredArchitecture()\n                .consideringOnlyDependenciesInLayers()\n                .layer(DOMAIN).definedBy(this.domainPackageIdentifier)\n                .layer(USECASE).definedBy(this.useCasePackageIdentifier)\n                .layer(ADAPTER).definedBy(this.adapterPackageIdentifier)\n                .optionalLayer(IGNORED_PACKAGES).definedBy(ignoredPackageIdentifiers.toArray(new String[0]))\n                .optionalLayer(SHARED_OUTPUT_ADAPTER_PATTERN).definedBy(sharedOutputAdapter.toArray(new String[0]))\n                .optionalLayer(SHARED_KERNEL_PATTERN).definedBy(sharedKernel.toArray(new String[0]))\n                .optionalLayer(SUPPORTING_SERVICE_PATTERN).definedBy(supportingService.toArray(new String[0]))\n                .whereLayer(DOMAIN).mayOnlyBeAccessedByLayers(\n                        USECASE,\n                        ADAPTER,\n                        IGNORED_PACKAGES,\n                        SHARED_OUTPUT_ADAPTER_PATTERN\n                )\n                .whereLayer(USECASE).mayOnlyBeAccessedByLayers(\n                        ADAPTER,\n                        DOMAIN,\n                        IGNORED_PACKAGES,\n                        SHARED_OUTPUT_ADAPTER_PATTERN\n                )\n                .whereLayer(ADAPTER).mayNotBeAccessedByAnyLayer()\n                .whereLayer(SHARED_OUTPUT_ADAPTER_PATTERN).mayOnlyBeAccessedByLayers(\n                        USECASE,\n                        DOMAIN,\n                        IGNORED_PACKAGES\n                )\n                .whereLayer(SUPPORTING_SERVICE_PATTERN).mayOnlyBeAccessedByLayers(\n                        DOMAIN,\n                        IGNORED_PACKAGES\n                )\n                .whereLayer(SHARED_KERNEL_PATTERN).mayOnlyBeAccessedByLayers(\n                        DOMAIN,\n                        USECASE,\n                        ADAPTER,\n                        IGNORED_PACKAGES\n                )\n                .withOptionalLayers(true);\n\n        return layeredArchitectureDelegate.as(this.getDescription());\n    }\n\n    private void enrichWithAdapters(Architectures.LayeredArchitecture layeredArchitectureDelegate, Map&lt;String, String&gt; packageIdentifiers) {\n        Iterator var2;\n        Map.Entry adapter;\n        String adapterLayer;\n        for (var2 = packageIdentifiers.entrySet().iterator(); var2.hasNext(); layeredArchitectureDelegate = layeredArchitectureDelegate.layer(adapterLayer).definedBy((String[]) adapter.getValue()).whereLayer(adapterLayer).mayNotBeAccessedByAnyLayer()) {\n            adapter = (Map.Entry) var2.next();\n            adapterLayer = this.getAdapterLayer((String) adapter.getKey());\n        }\n    }\n\n    private String[] concatenateAll(Collection&lt;String[]&gt; arrays) {\n        List&lt;String&gt; resultList = new ArrayList();\n        Iterator var3 = arrays.iterator();\n\n        while (var3.hasNext()) {\n            String[] array = (String[]) var3.next();\n            resultList.addAll(Arrays.asList(array));\n        }\n\n        return (String[]) resultList.toArray(new String[0]);\n    }\n\n    private String getAdapterLayer(String name) {\n        return String.format(\"%s %s\", name, \"adapter\");\n    }\n\n    public void check(JavaClasses classes) {\n        this.layeredArchitectureDelegate().check(classes);\n    }\n\n    public ArchRule because(String reason) {\n        return Factory.withBecause(this, reason);\n    }\n\n    @Override\n    public ArchRule allowEmptyShould(boolean allowEmptyShould) {\n        this.optionalLayers = allowEmptyShould;\n        return this;\n    }\n\n    public CleanArchitecture as(String newDescription) {\n        return new CleanArchitecture(this.check,\n                Optional.of(newDescription),\n                domainModelPackageIdentifier,\n                domainServicePackageIdentifier,\n                usecaseInteractorPackageIdentifier,\n                adapterInPackageIdentifier,\n                adapterOutPackageIdentifier,\n                useCaseInPackageIdentifier,\n                useCaseOutPackageIdentifier,\n                useCasePackageIdentifier,\n                adapterPackageIdentifier,\n                domainPackageIdentifier,\n                adapterPackageIdentifiers,\n                optionalLayers,\n                allRingsDeepCheck,\n                ignoredDependencies,\n                sharedOutputAdapter,\n                ignoredPackageIdentifiers,\n                supportingService,\n                adapterOutOfAdapterOutUseCaseIn,\n                sharedKernel);\n    }\n\n    public EvaluationResult evaluate(JavaClasses classes) {\n        return this.layeredArchitectureDelegate().evaluate(classes);\n    }\n\n    public String getDescription() {\n        if (this.overriddenDescription.isPresent()) {\n            return (String) this.overriddenDescription.get();\n        } else {\n            return \"Clean architecture fitness function in mode \" + check.toString();\n        }\n    }\n\n    private static class IgnoredDependency {\n        private final DescribedPredicate&lt;? super JavaClass&gt; origin;\n        private final DescribedPredicate&lt;? super JavaClass&gt; target;\n\n        IgnoredDependency(DescribedPredicate&lt;? super JavaClass&gt; origin, DescribedPredicate&lt;? super JavaClass&gt; target) {\n            this.origin = origin;\n            this.target = target;\n        }\n\n        Architectures.LayeredArchitecture ignoreFor(Architectures.LayeredArchitecture layeredArchitecture) {\n            return layeredArchitecture.ignoreDependency(this.origin, this.target);\n        }\n    }\n\n}\n</code></pre> <pre><code>public enum CleanArchitectureCheck {\n    ARCHITECTURAL_EXPRESSIVE,\n    DOMAIN_RING_ARCHITECTURAL_EXPRESSIVE,\n    DOMAIN_AND_USECASE_RING_ARCHITECTURAL_EXPRESSIVE,\n    RINGS_AS_LAYERS;\n}\n</code></pre> <pre><code>import com.tngtech.archunit.base.HasDescription;\nimport com.tngtech.archunit.lang.FailureDisplayFormat;\nimport com.tngtech.archunit.lang.FailureMessages;\nimport com.tngtech.archunit.lang.Priority;\n\nimport static java.lang.System.lineSeparator;\nimport static java.util.stream.Collectors.joining;\n\npublic class CustomFailureDisplayFormat implements FailureDisplayFormat {\n    @Override\n    public String formatFailure(HasDescription rule, FailureMessages failureMessages, Priority priority) {\n        String failureDetails = failureMessages.stream()\n                .map(message -&gt; message.replaceAll(\"&lt;(?:\\\\w+\\\\.)+([A-Z][^&gt;]*)&gt;\", \"&lt;$1&gt;\"))\n                .collect(joining(lineSeparator()));\n\n        return String.format(\"Architecture Violation [Priority: %s] - Rule '%s' was violated (%s):%n%s\",\n                priority.asString(), rule.getDescription(), failureMessages.getInformationAboutNumberOfViolations(), failureDetails);\n    }\n}\n</code></pre> <p>Binde folgenden Code in dein Projekt ein. Versuche zu verstehen, was hier passiert und f\u00fchre den Tests aus. Zuvor musst du deinen Root Package Name angeben (anstelle von ). Wenn noch nicht vorhandne, muss du ebenfalls ArchUnit als Abh\u00e4ngigkeit in deinem Build Tool (Maven/Gradle) hinzuf\u00fcgen. <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.tngtech.archunit&lt;/groupId&gt;\n    &lt;artifactId&gt;archunit-junit5&lt;/artifactId&gt;\n    &lt;version&gt;1.2.0&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>import com.tngtech.archunit.core.domain.JavaClasses;\nimport com.tngtech.archunit.core.importer.ImportOption;\nimport com.tngtech.archunit.junit.AnalyzeClasses;\nimport com.tngtech.archunit.junit.ArchTest;\n\n@AnalyzeClasses(packages = \"&lt;YOUR ROOT PACKAGE&gt;\",\n        importOptions = {ImportOption.DoNotIncludeTests.class,\n                ImportOption.DoNotIncludeJars.class})\npublic class CleanArchitectureTemplateTest {\n\n    @ArchTest\n    void clean_architecture_fitness_function(JavaClasses classes) {\n        CleanArchitecture rule = CleanArchitecture.cleanArchitecture(CleanArchitectureCheck.ARCHITECTURAL_EXPRESSIVE)\n                .domainModel(\"..domain.model..\")\n                .domainService(\"..domain.service..\")\n                .adapterIn(\"..adapter.in..\")\n                .adapterOut(\"..adapter.out..\")\n                .usecaseInteractor(\"..usecase.interactor..\")\n                .useCaseIn(\"..usecase.in..\")\n                .useCaseOut(\"..usecase.out..\");\n\n        rule.check(classes);\n    }\n}\n</code></pre>"},{"location":"docs/lab6/lab6/#aufgabe-62-archunit-boardmittel","title":"Aufgabe 6.2 ArchUnit Boardmittel","text":"<p>Mach dich vertraut mit: - ArchUnit: What to check - ArchUnit: Layered Architecture - ArchUnit: Onion Architecture - ArchUnit: Modularization Rules</p> <p>Implementiere einen ArchUnit Test f\u00fcr eine Pr\u00fcfungsregeln in der Clean Architecture.</p>"},{"location":"docs/old/lab1/","title":"Entities und Use Cases","text":""},{"location":"docs/old/lab1/#aufgabe-1-domanenmodell-vehicle","title":"Aufgabe 1 Dom\u00e4nenmodell Vehicle","text":"<p>Implementiere das dargestellte Dom\u00e4nenmodell</p> <p> Abb 1: Vehicle Domain Model -  - Vehicle ist die Root Entity des Dom\u00e4nenmodell. <li>Implementiere die untergeordneten Dom\u00e4nenobjekte als Value Object</li> <li>Erstelle das Package vehicle.domain.model und lege die Dom\u00e4nenobjekte in diesem Package ab</li></p> <li>Implementiere die im folgenden aufgef\u00fchrten Validierungsregeln in den betroffenen Dom\u00e4nenobjekte</li> Coding Task 1 Dom\u00e4nenmodell Vehicle <ol> <li>Implementiere das dargestellte Dom\u00e4nenmodell Vehicle</li> <li>Vehicle ist die Root Entity des Dom\u00e4nenmodell.</li> <li>Implementiere die untergeordneten Dom\u00e4nenobjekte als Value Object</li> <li>Erstelle das Package vehicle.domain.model und lege die Dom\u00e4nenobjekte in diesem Package ab</li> <li>Implementiere die im folgenden aufgef\u00fchrten Validierungsregeln in den betroffenen Dom\u00e4nenobjekte</li> </ol> Domain Object Validation Rule Vehicle Alle Eigenschaften m\u00fcssen vorhanden und f\u00fcr sich valide sein. VIN Ein valider Wert muss dem Vin-Regex-Pattern folgen. LicensePlate Ein valider Wert muss dem LicensePlate-Regex-Pattern folgen. Mileage Der Kilometerstand muss gr\u00f6\u00dfer 0 sein. EquipmentCode Ein valider Wert muss dem EquipmentCode-Regex-Pattern folgen. Alle anderen Dom\u00e4nenobjekte Kein Nullwerte, keine leeren oder blank Strings Vin-Regex-Pattern <pre><code>// examples\n// WP0ZZZ99ZTS392155\n// WBAOLZ99ZTS349156\n\n\"(?=.*\\\\d|=.*[A-Z])(?=.*[A-Z])[A-Z0-9]{17}\"\n</code></pre> LicensePlate-Regex-Pattern <pre><code> \"[A-Z\u00d6\u00dc\u00c40-9]{1,5}[-]{0,1}[A-Z\u00d6\u00dc\u00c40-9]{0,10}[-]{0,1}[A-Z\u00d6\u00dc\u00c40-9]{0,4}\"\"[A-Z\u00d6\u00dc\u00c40-9]{1,5}[-]{0,1}[A-Z\u00d6\u00dc\u00c40-9]{0,10}[-]{0,1}[A-Z\u00d6\u00dc\u00c40-9]{0,4}\"  \n</code></pre> EquipmentCode-Regex-Pattern <pre><code>// examples\n// WP0ZZZ99ZTS392155\n// WBAOLZ99ZTS349156\n\n\"(?=.*\\d|=.*[A-Z])(?=.*[A-Z])[A-Z0-9]{17}\"\n</code></pre> Tests Coding Task 1 RUN DomainEntityTest     RUN CleanArchitectureFitnessFunction"},{"location":"docs/old/lab1/#domain-service-und-use-cases","title":"Domain Service und Use Cases","text":"Coding Task 2 Erstelle die ein- und ausgehenden Use Cases sowie den Use-Case-Connector (Stereotype Service) <ol> <li>Erstelle das Package domain.service als Subpackage von vehicle und erstelle die Klasse VehicleService </li> <li>Erstelle die Packages usecase.in und usecase.out als Subpackages von vehicle</li> <li>Erstelle den eingehenden Use Case VehicleCommand im daf\u00fcr vorgesehenen Package mit der Schnittstelle createVehicle</li> <li>Erstelle die ausgehenden Use Cases VehicleRepository und FetchVehicleMasterData im daf\u00fcr vorgesehenen Package mit den daf\u00fcr vorgesehenen Schnittstellen</li> <li>Implementiere den Anwendungsfall createVehicle im VehicleService</li> </ol> Schnittstelle VehicleCommand <pre><code>Vehicle createVehicle(Vin vin, VehicleMotionData vehicleMotionData);\n</code></pre> Schnittstelle VehicleRepository <pre><code>Vehicle save(Vehicle vehicle);\n</code></pre> Schnittstelle FetchVehicleMasterData <pre><code>VehicleMasterData fetch(Vin vin);\n</code></pre> Tests Coding Task 2 RUN UseCaseConnectorTest     RUN CleanArchitectureFitnessFunction"},{"location":"docs/old/lab2/","title":"Adapter Ring - Implementierung des Ports &amp; Adapters Pattern","text":""},{"location":"docs/old/lab2/#input-adapter","title":"Input Adapter","text":"Coding Task 3 Erstelle einen Input Adapter f\u00fcr den eingehenden Use Case <ol> <li>Erstelle das Package adapter.in als Subpackage von vehicle und erstelle den Interface Adapter VehicleController</li> <li>Implementiere die technische HTTP Schnittstelle zur Anlage eines Fahrzeugs und nutze hierf\u00fcr den Use Case VehicleCommand</li> <li>Erstelle das DTO VehicleResource (siehe Vorlage) und ein Mapper (VehicleWebMapper) f\u00fcr das DTO</li> <li>Ignoriere Details des Frameworks und des REST Architekturstils bei der Implementierung</li> </ol> VehicleResource     ```java public class VehicleResource {      private String vin;     private VehicleMotionDataResource vehicleMotionData;     private VehicleMasterDataResource vehicleMasterData;      public VehicleMasterDataResource getVehicleMasterData() {         return vehicleMasterData;     }      public void setVehicleMasterData(VehicleMasterDataResource vehicleMasterData) {         this.vehicleMasterData = vehicleMasterData;     }      public String getVin() {         return vin;     }      public void setVin(String vin) {         this.vin = vin;     }      public VehicleMotionDataResource getVehicleMotionData() {         return vehicleMotionData;     }      public void setVehicleMotionData(VehicleMotionDataResource vehicleMotionData) {         this.vehicleMotionData = vehicleMotionData;     } }     ```"},{"location":"docs/old/lab2/#output-adapter","title":"Output Adapter","text":"Coding Task 4 Erstelle die Output Adapter f\u00fcr die ausgehenden Use Cases <ol> <li>Erstelle das Package adapter.out als Subpackage von vehicle</li> und erstelle das Datenbank Repository VehicleDbRepository <li>Implementiere den Use Case VehicleRepository</li> <li>F\u00fchre das DTO VehicleDbEntity (siehe Vorlage) sowie den Mapper VehicleDbMapper ein</li> <li>Ignoriere Details des Frameworks bei der Implementierung</li> </ol> VehicleDbEntity     ```java public class VehicleDbEntity {      private String vin;     private String licensePlate;      public String getVin() {         return vin;     }      public void setVin(String vin) {         this.vin = vin;     }      public String getLicensePlate() {         return licensePlate;     }      public void setLicensePlate(String licensePlate) {         this.licensePlate = licensePlate;     } }     ```"},{"location":"docs/old/lab3/","title":"Domain Service Pattern des Domain Ring","text":""},{"location":"docs/old/lab3/#domain-service-pattern","title":"Domain Service Pattern","text":"<p>Ein Domain Service implementiert Business Logik, die keinem Dom\u00e4nenobjekt zugeordnet werden kann, oder  wenn f\u00fcr die Ausf\u00fchrung der Business Logik zus\u00e4tzlich Abh\u00e4ngigkeiten aufgebaut werden m\u00fcssen, die den  Abh\u00e4ngigkeitsregeln eines Dom\u00e4nenobjekts widersprechen w\u00fcrden</p>"},{"location":"docs/old/lab3/#anwendungsfall-risikobewertung-und-diebstahlprufung","title":"Anwendungsfall Risikobewertung und Diebstahlpr\u00fcfung","text":""},{"location":"docs/old/lab3/#coding-task-4","title":"Coding Task 4","text":"<p>Implementiere den TheftRiskRatingService </p> <ol> <li>Erstelle das Package domain.service als Subpackage von vehicle und erstelle den Domain Service TheftRiskRatingService</li> <li>Integriere die Risikobewertung in den Anlageprozess f\u00fcr ein Fahrzeug</li> <li>Betrachte das ausgebaute Dom\u00e4nenmodell in domain.service und nutze die Dom\u00e4nenobjekte</li> <li>Wird ein Risikobewertung &gt; 60 Risikopunkte ermittelt, muss eine Diebstahlabfrage bei Interpol durchgef\u00fchrt werden</li> <li>Erg\u00e4nze Use Case und Adapter Implementierung f\u00fcr die Diebstahlabfrage bei Interpol, f\u00fcr die Abfrage von Risikol\u00e4nder sowie -marken</li> </ol> <p></p> User Story Risikobewertung Fahrzeudiebstahl nach \u00a70815a  Als Produktmanager m\u00f6chte ich, dass die Risikobewertung f\u00fcr ein Fahrzeug im Anlageprozess durchgef\u00fchrt wird. Die Risikobewertung folgt dem im folgenden beschriebenen Regelwerk:  <ol> <li></li> </ol> Akzeptanzkriterien: <ol> <li></li> </ol> Erweitere Risikobewertung auf Basis von Risikol\u00e4nder und Risikomarken f\u00fcr die Risikobewertung nach \u00a70815a  Als Produktmanager m\u00f6chte dich die Risikobewertung nach \u00a70815a mit der Ber\u00fccksichtigung von Risikol\u00e4ndern und -marken erweitern.  <ol> <li></li> </ol> Akzeptanzkriterien: <ol> <li></li> </ol> <p>Weitere Informationen zur Risikobewertung und Diebstahlabfrage bei Interpol:</p> Use Case Diebstahlabfrage Interpol     ```java public interface DetectInterpolTheftStatus {     TheftStatus detect(Vin vin, LicensePlate licensePlate); }    ```  Use Case Abfrage Risikol\u00e4nder     ```java public interface FetchHighRiskCountries {     HighRiskCountries fetch(); }    ```  Use Case Abfrage Risikomarken     ```java public interface FetchHighRiskVehicleModels {     HighRiskVehicleModels fetch(); }    ```"},{"location":"docs/old/lab4/","title":"Weitere Designprinzipen","text":""},{"location":"docs/old/lab4/#encapsulation-und-lesbarkeit-durch-command-objekte","title":"Encapsulation und Lesbarkeit durch Command Objekte","text":""},{"location":"docs/old/lab4/#erweiterung-des-domanenmodell-mileage-und-mileage-history","title":"Erweiterung des Dom\u00e4nenmodell Mileage und Mileage History","text":""},{"location":"docs/old/lab4/#anwendungsfall-update-mileage-mit-plausibilitatsprufung","title":"Anwendungsfall Update Mileage mit Plausibilit\u00e4tspr\u00fcfung","text":"Coding Task 5 Implementiere die Abfrage von Fahrzeudaten anhand der Vin <li>F\u00fchre den eingehenden Use Case VehicleQuery mit der Schnittstelle wie unten beschrieben ein.</li> <li>Erweitere den ausgehenden Use Case VehicleRepository um die Schnittstelle wie unten beschrieben. <li>Implementiere den eingehenden Use Case im VehicleService</li> Schnittstelle VehicleQuery <pre><code>Vehicle findByVin(Vin vin);\n</code></pre> Schnittstelle VehicleRepository <pre><code>VehicleMotionData findVehicleMotionDataByVin(Vin vin);\n</code></pre>"},{"location":"docs/old/lab5/","title":"Abh\u00e4ngigkeiten zwischen Dom\u00e4nenmodulen","text":""},{"location":"docs/old/lab5/#neue-domanenmodule","title":"Neue Dom\u00e4nenmodule","text":"<p>Investigate the introduced domain modules GarageOrder and PartsCatalogue. Both domain modules depends on the Vehicle domain module.</p> <p>In context of the garage order only the license plate and, the mileage of a vehicle are relevant.</p> <p>For the parts catalogue only the vin, the vehicle model and, the domain value has5GSupport are from importance.</p> <p>See the garage order form for more details:</p> <p></p> <p>See also the explosion chart of the front brake, as a example for the graphical visualization of a spare part in the parts catalogue:</p> <p></p> <p>Additional information are described in the corresponding spare parts table.</p> <p></p>"},{"location":"docs/old/lab5/#kopplung-zwischen-wurzelobjekten-und-domanenmodulen-neu-denken","title":"Kopplung zwischen Wurzelobjekten und Dom\u00e4nenmodulen neu denken","text":"<p>In a traditional data-centric and layered architecture, it is common to design the application around a centric data model. But this leads to high coupling in the long term (see section \"Problems of Layered Architecture\" in the trainings slides). In this lab the Adapter.Out - UseCase.In Pattern and the Application Service Pattern are described. Additional approaches are shown in the training slides.</p>"},{"location":"docs/old/lab5/#the-adapterout-usecasein-pattern","title":"The Adapter.Out - UseCase.In Pattern","text":"<p>Implement the Adapter.Out - UseCase.In Pattern between the domain modules Garage order and Vehicle.</p>"},{"location":"docs/old/lab5/#introduce-the-use-case-fetchvehiclebylicenseplate-vehicle-module","title":"Introduce the Use Case FetchVehicleByLicensePlate (Vehicle Module)","text":"Coding Task 6.1 <ol> <li>          Introduce an additional incoming use case in the domain module Vehicle with the name           FetchVehicleByLicensePlate. The use case should contain the method fetchByLicensePlate </li> <li>          Implement the use case by extending the VehicleQueryService.       </li> </ol> Java <pre><code>Vehicle fetchByLicensePlate(LicensePlate licensePlate);\n</code></pre> Kotlin <pre><code>fun fetchByLicensePlate(licensePlate: LicensePlate): Vehicle;\n</code></pre> C# <pre><code>Vehicle FetchByLicensePlate(LicensePlate licensePlate);\n</code></pre> Verify 6.1 RUN DomainRing_Task_6_1     RUN ArchitectureTest_Task_6_1 (Java &amp; Kotlin)     RUN all architecture tests (C#)"},{"location":"docs/old/lab5/#implement-the-use-case-fetchvehicle-garage-order-module","title":"Implement the Use Case FetchVehicle (Garage Order Module)","text":"Coding Task 6.2 <ol> <li>          Have a look at the outgoing use case FetchVehicle in garage/order/usecase/out </li> <li>          Implement the output adapter with the name VehicleModuleClient and a mapper with the name           VehicleToOriginVehicleMapper.       </li> </ol> Verify 6.2 RUN OutputAdapter_Task_6_2     RUN ArchitectureTest_Task_6_2 (Java &amp; Kotlin)     RUN all architecture tests (C#)"},{"location":"docs/old/lab5/#the-application-service-pattern","title":"The Application Service Pattern","text":"Coding Task 6.3 Implement the Application Service Pattern between the domain modules Parts Catalogue and Vehicle. <ol> <li>       Have a look at the ExplosionChartApplicationService in parts/catalogue/appservice and notice the dependency to       VehicleQuery of the domain module vehicle.    </li> <li>         Complete the implementation of the use case ExplosionChartQuery in ExplosionChartQueryService </li> <li>         Use VehicleQuery from the vehicle module to fetch necessary vehicle data    </li> <li>         Implement and use the mapper VehicleToOriginVehicleMapper </li> </ol> Verify 6.3 RUN ApplicationService_Task_6_3     RUN ArchitectureTest_Task_6_3 (Java &amp; Kotlin)     RUN all architecture tests (C#)"},{"location":"docs/old/lab5/#clean-architecture-fitness-functions-currently-not-working","title":"Clean Architecture Fitness Functions - Currently Not Working","text":"Optional Coding Task 6.4 <ol> <li> RUN CleanArchitectureTest    </li> <li>       Fix the test by extending the test should_check_clean_architecture_all_rings_architectural_expressive </li> <li> RUN CleanArchitectureTest again. Why did the test pass now?    </li> </ol> Java &amp; Kotlin <pre><code>.adapterOutOfAdapterOutUseCaseInPattern(\"..garage.order.adapter.out..\")\n.applicationService(\"..parts.catalogue.appservice..\")\n</code></pre>"}]}